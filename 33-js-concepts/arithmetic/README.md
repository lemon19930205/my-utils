# 算法

## *JS中的算法其实就是各种排序*

### 冒泡排序

- 原理：
   1. 比较相邻元素。如果第一个比第二个大，就交换它们两个；
   2. 对每一对相邻元素作同样的工作，从开始第一对到结尾最后一对，这样在最后的元素应该会是最大的数；
   3. 针对所有的元素重复以上步骤，除了最后一个；
   4. 重复步骤1~3，知道排序完成。
- 改进1：设置标志性变量pos，用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位，故在进行下一躺排序时只要扫描到pos位置即可。
- 改进2：传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值，我们考虑利用在每趟排序中进行正向和反向两边冒泡的方法一次可以得到两个最终值（最大和最小值），从而使排序躺数几乎减少一半。

### 选择排序

- 原理：
   1. 初始状态：无序区为R[1...n]，有序区为空；
   2. 第i躺排序（i=1,2,3...n-1）开始时，当前有序区和无序区分别为R[1...i-1]和R[i...n]。该躺排序从当前无序区中选出关键字最小的记录R[k]，将它与无序区第一个记录R交换，使R[1...i]和R[i+1...n]分别改变为记录个数增加1个的新有序区和记录个数减少一个的新无序区；
   3. n-1躺结束，数组就有序化了。

### 插入排序

- 原理：（类似扑克牌摸牌）
   1. 从第一个元素开始，该元素可以认为已经被排序；
   2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
   3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；
   4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
   5. 将新元素插入到该位置后；
   6. 重复步骤2-5。
- 改进：查找插入位置时使用二分查找的方式（二分查找：在有序区间内确认中间位置，分为两个区间，判断元素所属区间，再确认中间位置...最终确认新元素在有序区间的位置）

