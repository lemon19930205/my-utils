# 算法

## *JS中的算法其实就是各种排序*

### 冒泡排序

- 原理：重复遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们调换过来。遍历重复至没有需要调换的元素，说明此时该数列的排序完成。
   1. 比较相邻元素。如果第一个比第二个大，就交换它们两个；
   2. 对每一对相邻元素作同样的工作，从开始第一对到结尾最后一对，这样在最后的元素应该会是最大的数；
   3. 针对所有的元素重复以上步骤，除了最后一个；
   4. 重复步骤1~3，知道排序完成。
- 改进1：设置标志性变量pos，用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位，故在进行下一躺排序时只要扫描到pos位置即可。
- 改进2：传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值，我们考虑利用在每趟排序中进行正向和反向两边冒泡的方法一次可以得到两个最终值（最大和最小值），从而使排序躺数几乎减少一半。

### 选择排序

- 原理：首先在未排序序列中找到最小（大）元素，存放到起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直至排序完成。
   1. 初始状态：无序区为R[1...n]，有序区为空；
   2. 第i躺排序（i=1,2,3...n-1）开始时，当前有序区和无序区分别为R[1...i-1]和R[i...n]。该躺排序从当前无序区中选出关键字最小的记录R[k]，将它与无序区第一个记录R交换，使R[1...i]和R[i+1...n]分别改变为记录个数增加1个的新有序区和记录个数减少一个的新无序区；
   3. n-1躺结束，数组就有序化了。

### 插入排序

- 原理：（类似扑克牌摸牌），一般都采用in-place在数组上实现
   1. 从第一个元素开始，该元素可以认为已经被排序；
   2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
   3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；
   4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
   5. 将新元素插入到该位置后；
   6. 重复步骤2-5。
- 改进：查找插入位置时使用二分查找的方式（二分查找：在有序区间内确认中间位置，分为两个区间，判断元素所属区间，再确认中间位置...最终确认新元素在有序区间的位置）

### 希尔排序（？？：理解了一点点）

- 原理：又叫缩小增量排序，先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序
   1. 选择一个增量序列t1,t2...tk，其中ti>tj，tk>1；
   2. 按增量序列的个数k，对序列进行k趟排序；
   3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序。仅增量因此为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。

### 归并排序

- 原理：将已有序的子序列合并，等到完全有序的子序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合成一个有序表，称为2路归并。
   1. 把长度为n的输入序列分成两个长度为n/2的子序列；
   2. 对着两个自学列分别采用归并排序（即：一直二分下去，直至分成两个长度为1的数组，然后分别归并，最终成为两个有序数组）；
   3. 将两个排序好的子序列合并成一个最终的有序序列。

### 快速排序（？：只理解了递归到最后合并的方法）

- 原理：通过一趟排序将待排记录分隔成独立的两个部分，其中一部分记录的元素均比另一部分的元素小，则可分别对这里两部分记录继续进行排序，一达到整个序列有序。
   1. 从数列中挑出一个元素，称为“基准”（pivot）
   2. 重新排序数列，所有元素比基准值小的放基准前面，比基准大的放在基准后面（相同的可以放在任意一边）。在这个分区推出后，该基准就处于数列的中间位置。称这个为分区（partition）操作；
   3. 递归的（recursive）把小于基准值的元素的子数列和大于基准值元素的子数列排序。

### 堆排序（？？？：完全没搞懂）

- 原理：利用堆这种数据解构所设计的。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的简直或索引总是小于或者大于他的父节点。
   1. 将初始待排序元素序列（R1,R2...Rn）构建成大顶堆，此堆为初始的无序区；
   2. 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区（R1,R2...Rn-1）和新的有序区（Rn），且满足R[1,2...n-1]<=R[n]；
   3. 由于交换后的新堆顶R[1]可能违反堆的性质，因此需要对当前无序区（R1,R2...Rn-1）调整为新堆，然后再次将R[1]与无序区的最后一个元素调换，得到新的无序区（R1,R2...Rn-2）和新的有序区（Rn-1,Rn）。不断重复此过程知道有序区的元素个数为n-1,则排序完成。

### 计数排序

- 原理：使用一个格外的数组C，其中第i个元素是待排序数组A中值等于i的元素个数。然后根据数组C来将A中的元素排到正确的位置。它只能对有限范围的整数进行排序。
   1. 找出待排序数组中的最大最小元素；
   2. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
   3. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
   4. 反向填充目标数组：将每个元素i放在新数组的第C（i）项，每放一个元素就将C（i）减去1。

### 桶排序

- 原理：计数排序的升级版。假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶在分别排序（有可能在使用别的排序算法或者是以递归的方式继续使用桶排序），最后合并所有的桶。
   1. 设置一个定量的数组当作空桶；
   2. 遍历输入的数据，并把数据一个一个放到对应的桶中；
   3. 对每个不是空的桶进行排序；
   4. 从不是空的桶把排序好的数据拼接起来。

### 基数排序

- 原理：按照低位先排序，然后收集；再按照高位排序，然后再手机；依次类推，知道最高级。可以针对属性的优先级进行排序，最后的次序是高优先级在前，高优先级相同的低优先级在前。基于分别是排序和分别收集，所以是稳定的。
   1. 取得数组中的最大数，并取得位数。
   2. arr为原始数组，从最低位开始取每个位组成radix数组；
   3. 对redix进行计数排序（利用基数排序适用于小范围数排序的特点）